/**
 * @file ir.hpp
 * @author Filip Novak
 * @date 2025-12-13
 *
 * Definitions of the internal representation (IR) of a .qasm program.
 * This IR is built by visitors of the parse tree generated by ANTLR.
 * It includes registers, gate definitions (atomic and composite), 
 * and program nodes supporting loops and conditionals.
 */
#pragma once

#include <string>
#include <vector>
#include <unordered_map>
#include <cstddef>
#include <variant>
#include <memory>

using idGate = std::size_t;
using idRegister = std::size_t;

enum class RegisterKind {
    Parametric,
    Nonparametric
};

enum class RegisterType {
    Qubit,
    Int
};

struct RegisterDef {
    std::string name;
    RegisterKind kind;
    RegisterType type;
    std::size_t size; // -1 if kind is parametric
};

struct RegisterRef {
    idRegister reg_id;
    std::ptrdiff_t qubit_index;
};

struct IndexExpr {
    bool is_constant;               // true if constant
    std::ptrdiff_t constant_value;  // valid if is_constant
    std::string symbol;             // e.g., "n", valid if !is_constant
    std::ptrdiff_t offset;          // e.g., n-2 -> symbol="n", offset=-2
};

enum class GateKind {
    Atomic,
    Composite
};

struct AtomicGateSemantics {
    // TODO: matrix or other atomic operations
};

struct GatePlacement {
    idGate gate_id;
    std::string gate_name;
    std::vector<std::size_t> relativeInputs;
};

struct CompositeGateBody {
    std::vector<GatePlacement> body; // TODO: can consist only of gate placements or for/while/if-else as well?
};

struct GateDef {
    std::string name;
    std::size_t num_qubits;
    GateKind kind;
    std::variant<AtomicGateSemantics, CompositeGateBody> semantics;
};

struct ProgramNodeBase;
struct GateApplication;
struct LoopApplication;
struct ConditionalApplication;

using ProgramNodePtr = std::unique_ptr<ProgramNodeBase>;

struct ProgramNodeBase {
    virtual ~ProgramNodeBase() = default;
};

struct GateApplication : ProgramNodeBase {
    idGate gate_id;
    std::vector<RegisterRef> operands;
};

struct LoopApplication : ProgramNodeBase {
    IndexExpr start;
    IndexExpr end;
    std::ptrdiff_t step;
    std::vector<ProgramNodePtr> body; // recursive
};

struct ConditionalApplication : ProgramNodeBase {
    std::string condition_expr;           // TODO: parse custom expression
    std::vector<ProgramNodePtr> then_body;
    std::vector<ProgramNodePtr> else_body;
};

class IR {
public:
    // Registers
    std::size_t addRegister(const RegisterDef& def);
    const RegisterDef& getRegister(std::size_t id) const;
    const RegisterDef& getRegister(const std::string& name) const;
    bool hasRegister(const std::string& name) const;

    // Gates
    std::size_t addGate(const GateDef& def);
    const GateDef& getGate(std::size_t id) const;
    const GateDef& getGate(const std::string& name) const;
    bool hasGate(const std::string& name) const;

    // Program
    void addProgramNode(ProgramNodePtr node);
    const std::vector<ProgramNodePtr>& getProgram() const;

private:
    std::vector<RegisterDef> registers;
    std::vector<GateDef> gates;
    std::vector<ProgramNodePtr> program;

    std::unordered_map<std::string, std::size_t> register_table;
    std::unordered_map<std::string, std::size_t> gate_table;
};

/* EOF ir.hpp */
