/**
 * @file ir.hpp
 * @author Filip Novak
 * @date 2025-12-27
 *
 * Definitions of the internal representation (IR) of a .qasm program.
 * This IR is built by visitors of the parse tree generated by ANTLR.
 * It includes registers, gate definitions (atomic and composite), 
 * and program nodes supporting loops and conditionals.
 * From this representation, output for other tools is produced.
 */
#pragma once

#include <string>
#include <vector>
#include <unordered_map>
#include <cstddef>
#include <variant>
#include <memory>
#include <optional>

using idGate = std::size_t;
using idRegister = std::size_t;


struct TypeExpr {
    std::string base;
    std::vector<std::string> dims;
    bool is_const = false;
};


enum class RegisterKind {
    Parametric,
    Nonparametric
};

enum class RegisterType {
    Qubit,
    Int
};

struct RegisterDef {
    std::string name;
    RegisterKind kind;
    RegisterType type;
    std::string size;
};

struct RegisterRef {
    idRegister reg_id;
    std::string qubit_index;
};

struct IndexExpr {
    bool is_constant;               // true if constant
    std::ptrdiff_t constant_value;  // valid if is_constant
    std::string symbol;             // e.g., "n", valid if !is_constant
    std::ptrdiff_t offset;          // e.g., n-2 -> symbol="n", offset=-2
};

enum class GateKind {
    Atomic,
    Composite
};

struct AtomicGateSemantics {
    std::string matrix;
};


struct GatePlacement {
    idGate gate_id;
    std::string gate_name;
    std::vector<size_t> relativeInputs;
};

struct RepeatBlock;

using GateStmt = std::variant<
    GatePlacement,
    RepeatBlock
>;

struct RepeatBlock {
    size_t count;   // must be compile time
    std::vector<GateStmt> body;
};

struct CompositeGateBody {
    std::vector<GateStmt> body;
};

struct GateDef {
    std::string name;
    std::vector<std::string> aliases;

    std::vector<std::string> argument_qubits;
    std::vector<std::string> parameters;

    std::unordered_map<std::string, std::size_t> argument_index;
    std::unordered_map<std::string, std::size_t> parameter_index;

    GateKind kind;
    std::variant<AtomicGateSemantics, CompositeGateBody> semantics;
    bool used = false;
};
struct ProgramNodeBase;
struct GateApplication;
struct LoopApplication;
struct ConditionalApplication;
struct VariableDef;



using ProgramNodePtr = std::unique_ptr<ProgramNodeBase>;

struct Block {
    std::vector<VariableDef> variables;   // declared here only
    std::vector<ProgramNodePtr> body; // for program blocks
};

struct ProgramNodeBase {
    virtual ~ProgramNodeBase() = default;
};

struct GateApplication : ProgramNodeBase {
    idGate gate_id;
    std::vector<RegisterRef> operands;
};

struct Interval {
    std::string start;
    std::string step = "1";
    std::string end;
};

using LoopValues = std::variant<
    Interval,                  // [start : step : end]
    std::vector<std::string>,  // {1, 5, 10}
    std::string                // identifier / expression (e.g. my_array)
>;

struct LoopApplication : ProgramNodeBase {
    // for uint i in [0:n-2]

    // for int[32] j in {1, 5, 10}

    // array[float[64], 4] my_floats = {1.2, -3.4, 0.5, 9.8};
    // for float[64] f in my_floats
    TypeExpr type; // uint | int[32] | float[64]
    std::string variable; // i | j | f
    LoopValues values;
    Block body;
};

struct ConditionalApplication : ProgramNodeBase {
    std::string condition_expr;           // TODO: parse custom expression
    std::vector<ProgramNodePtr> then_body;
    std::vector<ProgramNodePtr> else_body;
};

// struct SubroutineCall : ProgramNodeBase {
//     std::string name;
//     std::vector<std::string> arguments;
// };

enum class ParamPassing {
    ByValue,
    ByReference
};

enum class ParamMutability {
    Readonly,
    Mutable,
    None 
};


struct ParameterDef {
    std::string name;
    //TypeExpr type;
    std::string type; // todo change: to TypeExpr
    ParamPassing passing;
    ParamMutability mutability;
};

// struct ReturnStatement : ProgramNodeBase {
//     std::optional<std::string> value;
// };

struct SubroutineDef {
    std::string name;
    std::vector<ParameterDef> parameters;
    std::optional<std::string> return_type;
    Block body;
    bool is_extern = false;
    bool used = false;

    // solves moving and copying issues
    SubroutineDef() = default;
    SubroutineDef(const SubroutineDef&) = delete;
    SubroutineDef& operator=(const SubroutineDef&) = delete;
    SubroutineDef(SubroutineDef&&) = default;
    SubroutineDef& operator=(SubroutineDef&&) = default;
};



struct Expr {
    virtual ~Expr() = default;
};
using ExprPtr = std::unique_ptr<Expr>;

struct LiteralExpr : Expr {
    std::string value; // "5", "1.2", "true"
};

struct SymbolExpr : Expr {
    std::string name; // n, i, arr
};

struct CallExpr : Expr {
    std::string function;           // "__nondet", "sizeof"
    std::vector<ExprPtr> arguments;
};

struct BinaryExpr : Expr {
    std::string op;                 // + - * /
    ExprPtr lhs;
    ExprPtr rhs;
};

struct VariableDef {
    std::string name;
    TypeExpr type;
    bool is_const;
    std::string compile_time_value;
    std::string initializer; // todo change to expr
};



class IR {
public:
    // Registers
    std::size_t addRegister(const RegisterDef& def);
    const RegisterDef& getRegister(std::size_t id) const;
    const RegisterDef& getRegister(const std::string& name) const;
    const idRegister getRegisterId(std::string name) const;
    const std::vector<RegisterDef> getAllRegisters() const;
    bool hasRegister(const std::string& name) const;

    // Gates
    std::size_t addGate(const GateDef& def);
    const GateDef& getGate(std::size_t id) const;
    const GateDef& getGate(const std::string& name) const;
    GateDef& getGate(std::size_t id);
    GateDef& getGate(const std::string& name);
    const std::vector<GateDef> getAllGates() const;
    const idGate getGateId(std::string name) const;
    bool hasGate(const std::string& name) const;
    void markGateUsed(const std::string& name);
    void markGateUsed(std::size_t id);


    // Subroutines
    std::size_t addSubroutine(SubroutineDef&& def);
    const SubroutineDef& getSubroutine(std::size_t id) const;
    const SubroutineDef& getSubroutine(const std::string& name) const;
    SubroutineDef& getSubroutine(std::size_t id);
    SubroutineDef& getSubroutine(const std::string& name);
    const std::vector<SubroutineDef>& getAllSubroutines() const;
    const idGate getSubroutineId(std::string name) const;
    bool hasSubroutine(const std::string& name) const;
    void markSubroutineUsed(const std::string& name);
    void markSubroutineUsed(std::size_t id);


    Block& getGlobalBlock();
    const Block& getGlobalBlock() const;
    const VariableDef& getGlobalVariable(const std::string& name) const;


private:
    std::vector<RegisterDef> registers;
    std::vector<GateDef> gates;
    std::vector<SubroutineDef> subroutines;

    Block global_block;

    std::unordered_map<std::string, std::size_t> register_table;
    std::unordered_map<std::string, std::size_t> gate_table;
    std::unordered_map<std::string, std::size_t> subroutine_table;
};

/* EOF ir.hpp */
