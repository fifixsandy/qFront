/**
 * @file ir.hpp
 * @author Filip Novak
 * @date 2025-12-13
 *
 * Definitions of the internal representation (IR) of a .qasm program.
 * This IR is built by visitors of the parse tree generated by ANTLR.
 * It includes registers, gate definitions (atomic and composite), 
 * and program nodes supporting loops and conditionals.
 * From this representation, output for other tools is produced.
 */
#pragma once

#include <string>
#include <vector>
#include <unordered_map>
#include <cstddef>
#include <variant>
#include <memory>

using idGate = std::size_t;
using idRegister = std::size_t;

enum class RegisterKind {
    Parametric,
    Nonparametric
};

enum class RegisterType {
    Qubit,
    Int
};

struct RegisterDef {
    std::string name;
    RegisterKind kind;
    RegisterType type;
    std::string size;
};

struct RegisterRef {
    idRegister reg_id;
    std::string qubit_index;
};

struct IndexExpr {
    bool is_constant;               // true if constant
    std::ptrdiff_t constant_value;  // valid if is_constant
    std::string symbol;             // e.g., "n", valid if !is_constant
    std::ptrdiff_t offset;          // e.g., n-2 -> symbol="n", offset=-2
};

enum class GateKind {
    Atomic,
    Composite
};

struct AtomicGateSemantics {
    std::string matrix;
};

struct GatePlacement {
    idGate gate_id;
    std::string gate_name;
    std::vector<std::size_t> relativeInputs;
};

struct CompositeGateBody {
    std::vector<GatePlacement> body; // TODO: can consist only of gate placements or for/while/if-else as well?
};

struct GateDef {
    std::string name;

    std::vector<std::string> argument_qubits;
    std::vector<std::string> parameters;

    std::unordered_map<std::string, std::size_t> argument_index;
    std::unordered_map<std::string, std::size_t> parameter_index;

    GateKind kind;
    std::variant<AtomicGateSemantics, CompositeGateBody> semantics;
    bool used = false;
};
struct ProgramNodeBase;
struct GateApplication;
struct LoopApplication;
struct ConditionalApplication;

using ProgramNodePtr = std::unique_ptr<ProgramNodeBase>;

struct ProgramNodeBase {
    virtual ~ProgramNodeBase() = default;
};

struct GateApplication : ProgramNodeBase {
    idGate gate_id;
    std::vector<RegisterRef> operands;
};

struct Interval {
    std::string start;
    std::string step = "1";
    std::string end;
};

using LoopValues = std::variant<
    Interval,                  // [start : step : end]
    std::vector<std::string>,  // {1, 5, 10}
    std::string                // identifier / expression (e.g. my_array)
>;

struct LoopApplication : ProgramNodeBase {
    // for uint i in [0:n-2]

    // for int[32] j in {1, 5, 10}

    // array[float[64], 4] my_floats = {1.2, -3.4, 0.5, 9.8};
    // for float[64] f in my_floats
    std::string type; // uint | int[32] | float[64]
    std::string variable; // i | j | f
    LoopValues values;
    std::vector<ProgramNodePtr> body;
};

struct ConditionalApplication : ProgramNodeBase {
    std::string condition_expr;           // TODO: parse custom expression
    std::vector<ProgramNodePtr> then_body;
    std::vector<ProgramNodePtr> else_body;
};

class IR {
public:
    // Registers
    std::size_t addRegister(const RegisterDef& def);
    const RegisterDef& getRegister(std::size_t id) const;
    const RegisterDef& getRegister(const std::string& name) const;
    const idRegister getRegisterId(std::string name) const;
    const std::vector<RegisterDef> getAllRegisters() const;
    bool hasRegister(const std::string& name) const;

    // Gates
    std::size_t addGate(const GateDef& def);
    const GateDef& getGate(std::size_t id) const;
    const GateDef& getGate(const std::string& name) const;
    GateDef& getGate(std::size_t id);
    GateDef& getGate(const std::string& name);
    const std::vector<GateDef> getAllGates() const;
    const idGate getGateId(std::string name) const;
    bool hasGate(const std::string& name) const;

    // Program
    void addProgramNode(ProgramNodePtr node);
    const std::vector<ProgramNodePtr>& getProgram() const;
    std::vector<ProgramNodePtr>& getProgram();


private:
    std::vector<RegisterDef> registers;
    std::vector<GateDef> gates;
    std::vector<ProgramNodePtr> program;

    std::unordered_map<std::string, std::size_t> register_table;
    std::unordered_map<std::string, std::size_t> gate_table;
};

/* EOF ir.hpp */
